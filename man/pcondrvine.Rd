% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/pcondrvine.R
\name{pcondrvine}
\alias{pcondrvine}
\title{Conditional Distribution in a Regular Vine}
\usage{
pcondrvine(dat, rv, cond, vbls = vars(rv), maxint = 2, verbose = FALSE)
}
\arguments{
\item{dat}{vector or matrix of observations (columns are variables).}

\item{rv}{Regular vine object (complete).}

\item{cond}{Integer; the variable you wish to condition on (i.e. the
column number of \code{dat}, also present in \code{rv}).}

\item{vbls}{Vector of integers; the subset of variables you wish to consider.
Default is all variables in \code{rv}.}

\item{maxint}{Integer; maximum dimension of integration to tolerate. Put
\code{Inf} if you don't want an upper limit.}

\item{verbose}{Logical; should the function output how it goes about
finding the conditional distribution?}
}
\value{
A vector of length = the number of observations in \code{dat},
representing the evaluated conditional distribution of variable \code{cond}
given the other variables in \code{vbls}.

If integration beyond \code{maxint} dimensions is required to obtain
the quantities, then an error is thrown.
}
\description{
Evaluates the conditional distribution of a variable in a regular vine
out of all specified variables.
}
\details{
To compute the conditional distribution, the vine is subsetted to
the selected variables if possible. Then, if the conditioned variable is a
leaf, the conditional distributon is directly computed. If it's not a leaf,
the conditional distribution is computed by integrating the density.

If the subsetted vine does not exist, then the vine will be subsetted "as
much as possible", and the remaining variables that cannot be removed
will be integrated out to find the joint density of the selected variables,
from which the conditional cdf will be found.
}
\examples{
## D-Vine example
rv <- rvine(CopulaModel::Dvinearray(5), marg = identity)
rv <- trunc(rv, 2)
rv$copmat <- makeuppertri("bvncop", 2, 5, blanks = "")
rv$cparmat <- makeuppertri(c(1:7/10), 2, 5, byRow = FALSE)
udat <- fvinesim(10, rv)

## Compute 5|1:4. There's an algorithm for that.
pcondrvine(udat, rv, cond=5, verbose=T)

## Compute 5|4. pcondrvine just uses 'pcondcop()'.
pcondrvine(udat, rv, cond=5, vbls=c(4,5), verbose=T)

## Compute 5|2:3. Two integrals takes ~13 if maxint > 1.
pcondrvine(udat, rv, cond=5, vbls=c(2,3,5), maxint=1, verbose=T)

## Compute 4|(1,2,3,5). No algorithm for that.
pcondrvine(udat, rv, cond=4, verbose=T)
pcondrvine(udat, rv, cond=4, maxint=0, verbose=T) # No int. tolerance
}

