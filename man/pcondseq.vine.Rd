% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/pcondseq.R
\name{pcondseq.vine}
\alias{pcondseq.vine}
\title{Find sequential conditional cdfs -- From a Regular Vine}
\usage{
pcondseq.vine(ord, xdat, rvinefit, FX = identity, .print = FALSE,
  .print.cdfmethod = FALSE)
}
\arguments{
\item{ord}{Integer vector; variables in the order of finding conditional cdfs
(so we'll find \code{ord[1]}, \code{ord[2]|ord[1]}, etc.).}

\item{xdat}{Vector of a single observation, or matrix of multiple observations
of the variables (rows are observations, columns are variables whose column
number matches that of the vine array)}

\item{rvinefit}{The vine fit to data \code{xdat}. See details.}

\item{FX}{List of vectorized functions that are the marginals corresponding
to the columns of \code{xdat}. Or just one function if it's a common function.
Default is \code{identity} so that \code{xdat} can be uniform data if you want.}

\item{.print}{Logical; should the subsetted vines containing variables
\code{ord[1]}, \code{ord[1:2]}, ..., \code{ord} be printed?}

\item{.print.cdfmethod}{Logical; when a subset \code{ord[1:k]} is a vine,
should the method of evaluating the cdf be output? i.e., should the
\code{.print} argument of \code{\link{pcond.rvine}} be \code{TRUE}?}
}
\value{
If \code{dat} is a vector, returns a
vector of evaluated cdfs of predictors
\code{ord[1]}, \code{ord[2]|ord[1]}, ..., \code{ord[p]|ord[1:(p-1)]}.

If \code{dat} is a matrix, returns a matrix of such evaluated cdfs.
}
\description{
From a fitted regular vine model, evaluates the sequential conditional cdfs
of a selection of variables. For example, if you choose variables 4, 2, 6, 5
(in that order), then it evaluates the cdfs of 4, 2|4, 6|{4,2}, and 5|{4,2,6}.
}
\details{
The argument \code{rvinefit} can either be:

\enumerate{
     \item the output of \code{\link{VineCopula::RVineCopSelect}} (Version 1.6), or
     \item a list with the following named entries:
     \itemize{
         \item \code{A}: The vine array, as used in the
         package \code{\link{CopulaModel}}.
         \item \code{copmat}: An upper-triangular matrix of names of the
         bivariate copula models used in the vine.
         \item \code{cparmat}: An upper-triangular matrix of copula parameters
         to use in the corresponding copula model in \code{rvinefit$copmat}.
         Each entry should be a vector with length = the number of parameters
         for that copula model. See \code{\link{makeuppertri.list}} for help.
     }
}
}
\note{
This function is intended as a preliminary step before connecting a response
to predictors in some order.
}
\examples{
## Setup: D-vine
A <- truncvarray(CopulaModel::Dvinearray(6), 2)
copmat <- makeuppertri("frk", 2, 6, "")
cparmat <- makeuppertri(9:1/2, 2, 6)
dat <- fvinesim(10, A, copmat, cparmat)

## Get sequential cdfs:
pcondseq.vine(1:3, dat,
              rvinefit=list(A=A, copmat=copmat, cparmat=cparmat),
              .print = TRUE, .print.cdfmethod = TRUE)
pcondseq.vine(c(2, 1, 3, 4, 6, 5), dat,
              rvinefit=list(A=A, copmat=copmat, cparmat=cparmat),
              .print = TRUE, .print.cdfmethod = TRUE)
pcondseq.vine(c(4, 3, 6, 5, 1), dat,
              rvinefit=list(A=A, copmat=copmat, cparmat=cparmat),
              .print = TRUE, .print.cdfmethod = TRUE)
}
\seealso{
\code{\link{pcondseq.generic}}
}

